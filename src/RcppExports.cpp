// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/MSctmm.h"
#include <RcppArmadillo.h>
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// getQ
Rcpp::NumericMatrix getQ(const int nbStates, arma::vec alpha, arma::vec t_alpha, const time_t time, const double lng, const double lat, const int group, const String model);
RcppExport SEXP _MSctmm_getQ(SEXP nbStatesSEXP, SEXP alphaSEXP, SEXP t_alphaSEXP, SEXP timeSEXP, SEXP lngSEXP, SEXP latSEXP, SEXP groupSEXP, SEXP modelSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const int >::type nbStates(nbStatesSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type t_alpha(t_alphaSEXP);
    Rcpp::traits::input_parameter< const time_t >::type time(timeSEXP);
    Rcpp::traits::input_parameter< const double >::type lng(lngSEXP);
    Rcpp::traits::input_parameter< const double >::type lat(latSEXP);
    Rcpp::traits::input_parameter< const int >::type group(groupSEXP);
    Rcpp::traits::input_parameter< const String >::type model(modelSEXP);
    rcpp_result_gen = Rcpp::wrap(getQ(nbStates, alpha, t_alpha, time, lng, lat, group, model));
    return rcpp_result_gen;
END_RCPP
}
// kalman_rcpp
List kalman_rcpp(arma::mat& data, int nbStates, arma::vec param, arma::vec fixmu, arma::mat& Hmat);
RcppExport SEXP _MSctmm_kalman_rcpp(SEXP dataSEXP, SEXP nbStatesSEXP, SEXP paramSEXP, SEXP fixmuSEXP, SEXP HmatSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::mat& >::type data(dataSEXP);
    Rcpp::traits::input_parameter< int >::type nbStates(nbStatesSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type param(paramSEXP);
    Rcpp::traits::input_parameter< arma::vec >::type fixmu(fixmuSEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type Hmat(HmatSEXP);
    rcpp_result_gen = Rcpp::wrap(kalman_rcpp(data, nbStates, param, fixmu, Hmat));
    return rcpp_result_gen;
END_RCPP
}
// sample_path_mr
arma::mat sample_path_mr(const int a, const int b, const double t0, const double t1, const Rcpp::NumericMatrix& Q, const double k);
static SEXP _MSctmm_sample_path_mr_try(SEXP aSEXP, SEXP bSEXP, SEXP t0SEXP, SEXP t1SEXP, SEXP QSEXP, SEXP kSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int >::type a(aSEXP);
    Rcpp::traits::input_parameter< const int >::type b(bSEXP);
    Rcpp::traits::input_parameter< const double >::type t0(t0SEXP);
    Rcpp::traits::input_parameter< const double >::type t1(t1SEXP);
    Rcpp::traits::input_parameter< const Rcpp::NumericMatrix& >::type Q(QSEXP);
    Rcpp::traits::input_parameter< const double >::type k(kSEXP);
    rcpp_result_gen = Rcpp::wrap(sample_path_mr(a, b, t0, t1, Q, k));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _MSctmm_sample_path_mr(SEXP aSEXP, SEXP bSEXP, SEXP t0SEXP, SEXP t1SEXP, SEXP QSEXP, SEXP kSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_MSctmm_sample_path_mr_try(aSEXP, bSEXP, t0SEXP, t1SEXP, QSEXP, kSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// sample_path_mr2
arma::mat sample_path_mr2(const int a, const int b, const double t0, const double t1, const double lng0, const double lat0, const double lng1, const double lat1, const int group, const double k, const int nbStates, const arma::vec param, const arma::vec mu, const arma::mat& Hmat, const arma::vec alpha, const arma::vec t_alpha, const String model);
static SEXP _MSctmm_sample_path_mr2_try(SEXP aSEXP, SEXP bSEXP, SEXP t0SEXP, SEXP t1SEXP, SEXP lng0SEXP, SEXP lat0SEXP, SEXP lng1SEXP, SEXP lat1SEXP, SEXP groupSEXP, SEXP kSEXP, SEXP nbStatesSEXP, SEXP paramSEXP, SEXP muSEXP, SEXP HmatSEXP, SEXP alphaSEXP, SEXP t_alphaSEXP, SEXP modelSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const int >::type a(aSEXP);
    Rcpp::traits::input_parameter< const int >::type b(bSEXP);
    Rcpp::traits::input_parameter< const double >::type t0(t0SEXP);
    Rcpp::traits::input_parameter< const double >::type t1(t1SEXP);
    Rcpp::traits::input_parameter< const double >::type lng0(lng0SEXP);
    Rcpp::traits::input_parameter< const double >::type lat0(lat0SEXP);
    Rcpp::traits::input_parameter< const double >::type lng1(lng1SEXP);
    Rcpp::traits::input_parameter< const double >::type lat1(lat1SEXP);
    Rcpp::traits::input_parameter< const int >::type group(groupSEXP);
    Rcpp::traits::input_parameter< const double >::type k(kSEXP);
    Rcpp::traits::input_parameter< const int >::type nbStates(nbStatesSEXP);
    Rcpp::traits::input_parameter< const arma::vec >::type param(paramSEXP);
    Rcpp::traits::input_parameter< const arma::vec >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Hmat(HmatSEXP);
    Rcpp::traits::input_parameter< const arma::vec >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< const arma::vec >::type t_alpha(t_alphaSEXP);
    Rcpp::traits::input_parameter< const String >::type model(modelSEXP);
    rcpp_result_gen = Rcpp::wrap(sample_path_mr2(a, b, t0, t1, lng0, lat0, lng1, lat1, group, k, nbStates, param, mu, Hmat, alpha, t_alpha, model));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _MSctmm_sample_path_mr2(SEXP aSEXP, SEXP bSEXP, SEXP t0SEXP, SEXP t1SEXP, SEXP lng0SEXP, SEXP lat0SEXP, SEXP lng1SEXP, SEXP lat1SEXP, SEXP groupSEXP, SEXP kSEXP, SEXP nbStatesSEXP, SEXP paramSEXP, SEXP muSEXP, SEXP HmatSEXP, SEXP alphaSEXP, SEXP t_alphaSEXP, SEXP modelSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_MSctmm_sample_path_mr2_try(aSEXP, bSEXP, t0SEXP, t1SEXP, lng0SEXP, lat0SEXP, lng1SEXP, lat1SEXP, groupSEXP, kSEXP, nbStatesSEXP, paramSEXP, muSEXP, HmatSEXP, alphaSEXP, t_alphaSEXP, modelSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// smooth_rcpp
List smooth_rcpp(const arma::mat& data, int nbStates, const arma::vec param, const arma::vec fixmu, const arma::mat& Hmat);
RcppExport SEXP _MSctmm_smooth_rcpp(SEXP dataSEXP, SEXP nbStatesSEXP, SEXP paramSEXP, SEXP fixmuSEXP, SEXP HmatSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type data(dataSEXP);
    Rcpp::traits::input_parameter< int >::type nbStates(nbStatesSEXP);
    Rcpp::traits::input_parameter< const arma::vec >::type param(paramSEXP);
    Rcpp::traits::input_parameter< const arma::vec >::type fixmu(fixmuSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Hmat(HmatSEXP);
    rcpp_result_gen = Rcpp::wrap(smooth_rcpp(data, nbStates, param, fixmu, Hmat));
    return rcpp_result_gen;
END_RCPP
}
// makeMu
arma::mat makeMu(double tau_pos, double tau_vel, double dt);
RcppExport SEXP _MSctmm_makeMu(SEXP tau_posSEXP, SEXP tau_velSEXP, SEXP dtSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type tau_pos(tau_posSEXP);
    Rcpp::traits::input_parameter< double >::type tau_vel(tau_velSEXP);
    Rcpp::traits::input_parameter< double >::type dt(dtSEXP);
    rcpp_result_gen = Rcpp::wrap(makeMu(tau_pos, tau_vel, dt));
    return rcpp_result_gen;
END_RCPP
}
// makeSigma
arma::mat makeSigma(double tau_pos, double tau_vel, arma::mat sigma, double dt);
RcppExport SEXP _MSctmm_makeSigma(SEXP tau_posSEXP, SEXP tau_velSEXP, SEXP sigmaSEXP, SEXP dtSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type tau_pos(tau_posSEXP);
    Rcpp::traits::input_parameter< double >::type tau_vel(tau_velSEXP);
    Rcpp::traits::input_parameter< arma::mat >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< double >::type dt(dtSEXP);
    rcpp_result_gen = Rcpp::wrap(makeSigma(tau_pos, tau_vel, sigma, dt));
    return rcpp_result_gen;
END_RCPP
}

// validate (ensure exported C++ functions exist before calling them)
static int _MSctmm_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("arma::mat(*sample_path_mr)(const int,const int,const double,const double,const Rcpp::NumericMatrix&,const double)");
        signatures.insert("arma::mat(*sample_path_mr2)(const int,const int,const double,const double,const double,const double,const double,const double,const int,const double,const int,const arma::vec,const arma::vec,const arma::mat&,const arma::vec,const arma::vec,const String)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP _MSctmm_RcppExport_registerCCallable() { 
    R_RegisterCCallable("MSctmm", "_MSctmm_sample_path_mr", (DL_FUNC)_MSctmm_sample_path_mr_try);
    R_RegisterCCallable("MSctmm", "_MSctmm_sample_path_mr2", (DL_FUNC)_MSctmm_sample_path_mr2_try);
    R_RegisterCCallable("MSctmm", "_MSctmm_RcppExport_validate", (DL_FUNC)_MSctmm_RcppExport_validate);
    return R_NilValue;
}

static const R_CallMethodDef CallEntries[] = {
    {"_MSctmm_getQ", (DL_FUNC) &_MSctmm_getQ, 8},
    {"_MSctmm_kalman_rcpp", (DL_FUNC) &_MSctmm_kalman_rcpp, 5},
    {"_MSctmm_sample_path_mr", (DL_FUNC) &_MSctmm_sample_path_mr, 6},
    {"_MSctmm_sample_path_mr2", (DL_FUNC) &_MSctmm_sample_path_mr2, 17},
    {"_MSctmm_smooth_rcpp", (DL_FUNC) &_MSctmm_smooth_rcpp, 5},
    {"_MSctmm_makeMu", (DL_FUNC) &_MSctmm_makeMu, 3},
    {"_MSctmm_makeSigma", (DL_FUNC) &_MSctmm_makeSigma, 4},
    {"_MSctmm_RcppExport_registerCCallable", (DL_FUNC) &_MSctmm_RcppExport_registerCCallable, 0},
    {NULL, NULL, 0}
};

RcppExport void R_init_MSctmm(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
