% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runMCMC.R
\name{runMCMC}
\alias{runMCMC}
\title{Run MCMC iterations}
\usage{
runMCMC(
  track,
  nbStates,
  nbIter,
  fixpar = NULL,
  inits,
  priors,
  props,
  tunes,
  Hmat,
  updateState = TRUE,
  adapt = FALSE,
  mc.cores = 1
)
}
\arguments{
\item{track}{Dataframe of data, with columns "x", "y", "time", and "ID"}

\item{nbStates}{Number of states}

\item{nbIter}{Number of iterations}

\item{fixpar}{Vector of fixed parameter values (tau_pos, tau_vel, sigma), with NA for parameters to estimate}

\item{inits}{List of initial parameters
(tau_pos, tau_vel, sigma, Q, state)}

\item{priors}{List of parameters of prior distributions, with components:
\itemize{
  \item{"mean":} Vector of means for normal priors on movement parameters, of length 3*nbStates
  \item{"sd":} Vector of standard deviations for normal priors on movement parameters, of length
3*nbStates
  \item{"shape":} Vector of shapes of gamma priors for the transition rates
  \item{"rate":} Vector of rates of gamma priors for the transition rates
  \item{"con":} Vector of concentrations of Dirichlet priors for transition probabilities
}}

\item{props}{List of parameters of proposal distributions, with components:
\itemize{
  \item{"tau_posSD":} Scalar standard deviation for normal proposal distribution of tau_pos
  \item{"tau_velSD":} Scalar standard deviation for normal proposal distribution of tau_vel
  \item{"sigmaSD":} Scalar standard deviation for normal proposal distribution of sigma
  \item{"updateLim":} Vector of two values: min and max length of updated state sequence
  \item{"updateProbs":} Probability for each element of updateLim[1]:updateLim[2] (if NULL,
  all values are equiprobable)
}}

\item{tunes}{List of tuning parameters, with components:
\itemize{
  \item{"thinStates":} Thinning factor for the posterior state sequences (needed because
of memory limitations)
}}

\item{Hmat}{Matrix of observation error variance (four columns, and one row
for each row of data)}

\item{updateState}{Logical. If FALSE, the state process is not updated
(for exploratory analysis only, useful for testing single state models)}

\item{adapt}{Logical. If TRUE, use the the Robust Adaptive Metropolis (RAM) algorithm
by (Vihola 2012) to update the proposal distribution for each parameter.}

\item{mc.cores}{Integer specifying number of logical cores to use for likelihood
calculation when fitting to multiple IDs.}
}
\description{
Run MCMC iterations
}
\examples{
\dontrun{
#load ctmm for data and comparison
library(ctmm)
#load pelican dataset
data('pelican')
#extract argos data with errors and store in a dataframe
Pelican <- data.frame(x = pelican$argos$x, y = pelican$argos$y, time = pelican$argos$t, ID = 1, error = pelican$argos$VAR.xy )

#run 10000 iterations of a 2 state model (no error, but see commented line for example)
mcmc <- runMCMC( track = Pelican[,1:4], nbStates = 2, nbIter = 10000,
                fixpar = list( tau_pos = c( NA, NA ), tau_vel = c( NA, NA ), sigma = c( NA, NA ) ),
                inits = list( tau_pos = c( 13e6, 13e6 ),
                              tau_vel = c( 1e4, 1e4 ),
                              sigma = c( 2e11, 2e11 ),
                              Q = matrix( c( -0.05, 0.05, 0.05, -0.05 ), 2 ),
                              state = sample( 1:2, size = nrow( Pelican ), replace = TRUE ) ),
                priors = list( mean = log( c( 9e6, 9e6, 1e4, 1e4, 2e11, 2e11 ) ),
                               sd = c( 2, 2, 2, 2, 2, 2 ), shape = 2, rate = 10, con = 0 ),
                props = list( tau_posSD = 0.2, tau_velSD = 0.1, sigmaSD = 0.2, updateLim = c( 3, 150 ), updateProbs = rep( 1/148, 148 ) ),
                tunes = list( thinStates = 10000 * 0.001 ),
                #Hmat = cbind( Pelican$error, Pelican$error, matrix( rep( c( 0, 0 ), nrow( Pelican ) ), ncol = 2 ) ),
                Hmat = matrix( rep( c( 0, 0, 0 ,0 ), nrow( Pelican ) ), ncol = 4 ) ,
                mc.cores = 1 )

#parameter estimates (tau_pos1, tau_pos2, tau_vel1, tau_vel2, sigma1, sigma2)
colMeans( mcmc$allparam[ -( 1:( nrow( mcmc$allparam ) / 2 ) ) , ] )

#state sequence
round( colMeans( mcmc$allstates[ -( 1:nrow( mcmc$allstates ) / 2 ), ] ) )
}

}
