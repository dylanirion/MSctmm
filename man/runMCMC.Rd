% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runMCMC.R
\name{runMCMC}
\alias{runMCMC}
\title{Run MCMC iterations}
\usage{
runMCMC(
  track,
  nbStates,
  nbIter,
  fixpar = NULL,
  inits,
  priors,
  props,
  tunes,
  Hmat,
  updateState = TRUE,
  adapt = FALSE
)
}
\arguments{
\item{track}{Dataframe of data, with columns \code{"x"}, \code{"y"}, \code{"time"}, and \code{"ID"}}

\item{nbStates}{Number of states}

\item{nbIter}{Number of iterations}

\item{fixpar}{List of fixed parameter values (\code{"tau_pos"}, \code{"tau_vel"}, \code{"sigma"}), with \code{"NA"} for parameters to estimate}

\item{inits}{List of initial parameters (tau_pos, tau_vel, sigma, Q, state)}

\item{priors}{List of parameters of prior distributions, with components:
\itemize{
  \item{"mean":} Vector of means for normal priors on movement parameters, of length \code{"3*nbStates"}
  \item{"sd":} Vector of standard deviations for normal priors on movement parameters, of length \code{"3*nbStates"}
  \item{"shape":} Vector of shapes of gamma priors for the transition rates
  \item{"rate":} Vector of rates of gamma priors for the transition rates
  \item{"con":} Vector of concentrations of Dirichlet priors for transition probabilities
}}

\item{props}{List of parameters of proposal distributions, with components:
\itemize{
  \item{"S":} Initial value for the lower triangular matrix of RAM algorithm, so that the covariance matrix of the proposal distribution is \code{"SS'"}.
  \item{"updateLim":} Vector of two values: min and max length of updated state sequence
  \item{"updateProbs":} Probability for each element of \code{"updateLim[1]:updateLim[2]"} (if \code{"NULL"},
  all values are equiprobable)
}}

\item{tunes}{List of tuning parameters, with components:
\itemize{
  \item{"thinStates":} Thinning factor for the posterior state sequences (needed because
of memory limitations)
}}

\item{Hmat}{Matrix of observation error variance (four columns, and one row
for each row of data)}

\item{updateState}{Logical. If FALSE, the state process is not updated
(for exploratory analysis only, useful for testing single state models)}

\item{adapt}{Integer. (Experimental) If \code{"adapt"} > 0, use the the Robust Adaptive Metropolis (RAM) algorithm
by Vihola (2012) to update the proposal distribution for each parameter at each iteration (up to \code{"adapt"} iterations)
to a target acceptance rate of 23.4\%.}
}
\description{
Run MCMC iterations
}
\examples{
\dontrun{
#load ctmm for data and comparison
library(ctmm)
#load pelican dataset
data('pelican')
#extract argos data with errors and store in a dataframe
Pelican <- data.frame(x = pelican$argos$x, y = pelican$argos$y, time = pelican$argos$t, ID = 1, error = pelican$argos$VAR.xy )

#run 10000 iterations of a 2 state model (no error, but see commented line for example)
mcmc <- runMCMC( track = Pelican[,1:4], nbStates = 2, nbIter = 10000,
                fixpar = list( tau_pos = c( NA, NA ), tau_vel = c( NA, NA ), sigma = c( NA, NA ) ),
                inits = list( tau_pos = c( 13e6, 13e6 ),
                              tau_vel = c( 1e4, 1e4 ),
                              sigma = c( 2e11, 2e11 ),
                              Q = matrix( c( -0.05, 0.05, 0.05, -0.05 ), 2 ),
                              state = sample( 1:2, size = nrow( Pelican ), replace = TRUE ) ),
                priors = list( mean = log( c( 9e6, 9e6, 1e4, 1e4, 2e11, 2e11 ) ),
                               sd = c( 2, 2, 2, 2, 2, 2 ), shape = 2, rate = 10, con = 0 ),
                props = list( S = diag( c( 0.2, 0.2, 0.1, 0.1, 0.2, 0.2 ), 6 ), updateLim = c( 3, 150 ), updateProbs = rep( 1/148, 148 ) ),
                tunes = list( thinStates = 10000 * 0.001 ),
                #Hmat = cbind( Pelican$error, Pelican$error, matrix( rep( c( 0, 0 ), nrow( Pelican ) ), ncol = 2 ) ),
                Hmat = matrix( rep( c( 0, 0, 0 ,0 ), nrow( Pelican ) ), ncol = 4 ) )

#parameter estimates (tau_pos1, tau_pos2, tau_vel1, tau_vel2, sigma1, sigma2)
colMeans( mcmc$allparam[ -( 1:( nrow( mcmc$allparam ) / 2 ) ) , ] )

#state sequence
round( colMeans( mcmc$allstates[ -( 1:nrow( mcmc$allstates ) / 2 ), ] ) )
}

}
\references{
Michelot, T., Blackwell, P.G. (2019).
State‐switching continuous‐time correlated random walks.
Methods Ecol Evol, 10: 637-649. doi:10.1111/2041-210X.13154

Vihola, M. (2012).
Robust adaptive Metropolis algorithm with coerced acceptance rate.
Stat Comput, 22: 997-1008. doi:10.1007/s11222-011-9269-5
}
